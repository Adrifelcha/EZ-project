---
title: "EZ Bayesian Hierarchical Drift Diffusion Model"
author: "Adriana F. Chavez"
subtitle: "Based on Joachim's python code"
date: "Last time knitted: `r format(Sys.time(), '%d %B, %Y')`"
geometry: "left=1cm,right=1cm,top=2cm,bottom=2cm"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

-------------------

# Basic functions to generate DDM data

```{r}
# Part 1: Simulate single trial outcome
simulate_ddm <- function(a, v, dt, max_steps){
     x <- 0   
     random_dev <- rnorm(max_steps)  
     # Scale step changes by dt
     noise <- random_dev * sqrt(dt)
     drift <- v * dt
     
     for(i in 2:max_steps){
        this_step = drift + noise[i]
        x = x + this_step
            if(abs(x)>=(a/2)){  break  }
     }
     output <- list("RT" = (i+1)*dt, "C"  = x)
     return(output)
}

# Part 2: Simulate over 'n' trials
wdmrnd <- function(a,v,t,n){
    dt = 0.001
    max_steps = 10 / dt
    rt = rep(NA,n)
    accuracy = rep(NA,n)
    
    for(i in 1:n){
        X <- simulate_ddm(a, v, dt, max_steps)
        rt[i] <- X$RT 
        if(X$C>0){  accuracy[i] <- 1
          }else{    accuracy[i] <- 0  }
    }
    output <- data.frame("RT" = rt + t, "accuracy" = accuracy)
    return(output)
}
```

# Example: Generate some data

```{r}
a = 1.50
v = 0.00
t = 0.30
n = 10000

data <- wdmrnd(a, v, t, n)
rt <- data$RT
accuracy <- data$accuracy
```

```{r, echo=FALSE, fig.height=3.5}
par(mfrow = c(1, 3), 
    mar =c(5.1,2,4.1,2),
    bty = "o")

hist(rt[accuracy==1], ann=F, axes=F, breaks=50, col="lightgreen",
     border=NA)
mtext("Distribution of Reaction Times", 3, cex=0.65, line=0.5)
mtext("Reaction Time", 1, cex=0.6, line=2)
mtext("Count", 2, cex=0.6, line=1)
legend("topright", col="lightgreen", "Correct", pch=15, cex=0.7, bty="n")
axis(1,c(0:5),line=-0.7)

hist(rt[accuracy==0], ann=F, axes=F, breaks=50, col="indianred1",
     border=NA)
mtext("Distribution of Reaction Times", 3, cex=0.65, line=0.5)
mtext("Reaction Time", 1, cex=0.6, line=2)
mtext("Count", 2, cex=0.6, line=1)
legend("topright", col="indianred1", "Incorrect", pch=15, cex=0.7, bty="n")
axis(1,c(0:5),line=-0.7)

barplot(c(sum(1-accuracy),sum(accuracy)), ann=F, axes=F,
        col=c("red3","springgreen3"))
mtext("Accuracy Histogram", 3, cex=0.65, line=0.5)
mtext("Count", 2, cex=0.6, line=1)
axis(1,c(0.7,1.9),c("Incorrect","Correct"))
```


\clearpage

# Simulation Study environment and variables

## Auxiliary functions

The code for the auxiliary functions listed below is hidden from this .pdf file (but can be checked on the .Rmd file). 

1. `design_summary`: A function to print the settings used in the simulation.
2. `default_priors`: A function to load and print default prior values.
3. `sample_parameters`: A function to sample true parameter values from the priors specified.
4. `write_JAGSmodel`: A function to write the JAGS model using the prior values.
5. `data_toJAGS`: A function to create a list with all the data objects to be passed to JAGS.
6. `default_inits`:  A function to create an object containing initial values for the drift.
7. `extractSamples`: A function to extract all samples associated with a `parameter.name`
8. `plot.Chain`: A function to plot the merging chains for hierarchical parameters
9. `getError`: A function to compute the difference between the true value and estimate retrieved for every parameter.
10. `recoveryPlot` : A function to create a quick recovery plot

```{r, echo=FALSE}
# A function to print the settings used in the simulation
design_summary = function(nParticipants,nTrials){
          cat("========== EZBHDDM Design Parameters: =======\n")
          cat("Number of Participants:    ", nParticipants,"\n")
          cat("Trials Per Person:         ",nTrials,"\n")
}

# A function to load and print default prior values
default_priors <- function(Show=TRUE){
    prior <- data.frame("bound_mean_mean" = 1.50,
                        "bound_mean_sdev" = 0.20,
                        "drift_mean_mean" = 0.00,
                        "drift_mean_sdev" = 0.50,
                        "nondt_mean_mean" = 0.30,
                        "nondt_mean_sdev" = 0.06,
                        "bound_sdev_lower" = 0.10,
                        "bound_sdev_upper" = 0.20,
                        "drift_sdev_lower" = 0.20,
                        "drift_sdev_upper" = 0.40,
                        "nondt_sdev_lower" = 0.01,
                        "nondt_sdev_upper" = 0.05)
    if(Show){
          cat("========== EZBHDDM Priors: ==================\n")
          cat("Bound Mean Mean:   ", prior$bound_mean_mean,"\n")
          cat("Bound Mean Std Dev:",prior$bound_mean_sdev,"\n")
          cat("Drift Mean Mean:   ",prior$drift_mean_mean,"\n")
          cat("Drift Mean Std Dev:",prior$drift_mean_sdev,"\n")
          cat("Non-decision Time Mean Mean:",prior$nondt_mean_mean,"\n")
          cat("Non-decision Time Mean Std: ", prior$nondt_mean_sdev,"\n")
          cat("Bound Std Dev Shape:",prior$bound_sdev_lower,"\n")
          cat("Bound Std Dev Scale:",prior$bound_sdev_upper,"\n")
          cat("Drift Std Dev Shape:",prior$drift_sdev_lower,"\n")
          cat("Drift Std Dev Scale:",prior$drift_sdev_upper,"\n")
          cat("Non-decision Time Shape:",prior$nondt_sdev_lower,"\n")
          cat("Non-decision Time Scale:",prior$nondt_sdev_upper,"\n")
    }
  return(prior)
}

# A function to sample true parameter values from the priors specified
sample_parameters <- function(settings, Show=TRUE){
    prior <- settings$prior
    bound_mean <- rnorm(1,prior$bound_mean_mean,prior$bound_mean_sdev)    
    drift_mean <- rnorm(1,prior$drift_mean_mean,prior$drift_mean_sdev)
    nondt_mean <- rnorm(1,prior$nondt_mean_mean,prior$nondt_mean_sdev)
    bound_sdev <- runif(1,prior$bound_sdev_lower,prior$bound_sdev_upper)  
    drift_sdev <- runif(1,prior$drift_sdev_lower,prior$drift_sdev_upper)
    nondt_sdev <- runif(1,prior$nondt_sdev_lower,prior$nondt_sdev_upper)
    bound <- rnorm(settings$nPart,bound_mean, bound_sdev)
    drift <- rnorm(settings$nPart,drift_mean, drift_sdev)
    nondt <- rnorm(settings$nPart,nondt_mean, nondt_sdev)
    parameter_set <- list("bound_mean" = bound_mean, "drift_mean" = drift_mean, "nondt_mean" = nondt_mean, 
                          "bound_sdev" = bound_sdev, "drift_sdev" = drift_sdev, "nondt_sdev" = nondt_sdev,
                          "bound" = bound,   "drift" = drift,   "nondt" = nondt)
    if(Show){
          cat("===== EZBHDDM True Parameters: ==============\n")
          cat("Bound Mean:   ", bound_mean,"\n")
          cat("Bound SD:     ", bound_sdev,"\n")
          cat("Drift Mean:   ", drift_mean,"\n")
          cat("Drift SD:     ", drift_sdev,"\n")
          cat("Non-decision Time Mean:", nondt_mean,"\n")
          cat("Non-decision Time SD:  ", nondt_sdev,"\n")
          cat("=============================================\n")
    }
  return(parameter_set)
}

# A function to write the JAGS model using the prior values
write_JAGSmodel <- function(prior,modelFile = "EZHBDDM.bug"){
      modelFile <- "EZHBDDM.bug"
      
      opening <- "model{"
      prior.bound_m <- paste("          bound_mean ~ dnorm(", prior$bound_mean_mean,",pow(",prior$bound_mean_sdev,",-2))T(0.10,3.00)", sep="")
      prior.drift_m <- paste("          drift_mean ~ dnorm(", prior$drift_mean_mean,",pow(",prior$drift_mean_sdev,",-2))T(-3.00,3.00)", sep="")
      prior.nondt_m <- paste("          nondt_mean ~ dnorm(", prior$nondt_mean_mean,",pow(",prior$nondt_mean_sdev,",-2))T(0.05,1.00)", sep="")
      prior.bound_sd <- paste("          bound_sdev ~ dunif(", prior$bound_sdev_lower,",",prior$bound_sdev_upper,")", sep="")
      prior.drift_sd <- paste("          drift_sdev ~ dunif(", prior$drift_sdev_lower,",",prior$drift_sdev_upper,")", sep="")
      prior.nondt_sd <- paste("          nondt_sdev ~ dunif(", prior$nondt_sdev_lower,",",prior$nondt_sdev_upper,")", sep="")
      content <-"
              # Sampling model
              for (p in 1:nParticipants){
                  bound[p] ~ dnorm(bound_mean, pow(bound_sdev, -2))T(0.10,3.00)
                  drift[p] ~ dnorm(drift_mean, pow(drift_sdev, -2))T(-3.00,3.00)
                  nondt[p] ~ dnorm(nondt_mean, pow(nondt_sdev, -2))T(0.05,1.00)
                  
                  # Forward equations from EZ Diffusion
                  ey[p]  = exp(-bound[p] * drift[p])
                  Pc[p]  = 1 / (1 + ey[p])
                  PRT[p] = 2 * pow(drift[p], 3) / bound[p] * pow(ey[p] + 1, 2) / (2 * -bound[p] * drift[p] * ey[p] - ey[p]*ey[p] + 1)
                  MDT[p] = (bound[p] / (2 * drift[p])) * (1 - ey[p]) / (1 + ey[p])
                  MRT[p] = MDT[p] + nondt[p]
              
                  # Loss functions using MRT, PRT, and Pc
                  meanRT[p]  ~ dnorm(MRT[p], PRT[p] * correct[p])
                  varRT[p]   ~ dnorm(1/PRT[p], 0.5 * correct[p] * PRT[p] * PRT[p])
                  correct[p] ~ dbin(Pc[p], nTrialsPerPerson)
              }
      }"
      
      final_file <- file(modelFile)
            writeLines(c(opening,prior.bound_m,prior.drift_m,prior.nondt_m,
                         prior.bound_sd,prior.drift_sd,prior.nondt_sd,content),
                       final_file)
      close(final_file)
}

# A function to create a list with all the data objects in the JAGS model
data_toJAGS <- function(){
    passData <- list("nParticipants", "nTrialsPerPerson",
                     "meanRT", "varRT", "correct")
    return(passData)
}

default_inits <- function(n.chains,nParticipants){
  myinits <- rep(list(list()), n.chains)
  for(i in 1:n.chains){
      myinits[[i]] <- list(drift = rnorm(nParticipants,0,0.1))
  }
  return(myinits)
}

# A function to extract individual samples for any parameter
extractSamples <- function(parameter.name, samples){
        postParam.Array <- samples$BUGSoutput$sims.array
        samplesID <- names(postParam.Array[1,1,])
        locateParameter  <- which(grepl(parameter.name,samplesID))
        
        param.is.hierarchical <- length(which(grepl("_",parameter.name)))!=0
        if(!param.is.hierarchical){
          locateHierPar <- which(grepl("_",samplesID))
          locateParameter <- locateParameter[!locateParameter %in% locateHierPar]   
        }
        
        # Now, for individual/task level parameters...
        if(length(locateParameter)>1){
              # We isolate the pages ID that contain the parameter of interest
              samplesRelated <- samplesID[locateParameter]
              # We identify the maximum index
              locateParticipantID <-as.numeric(gsub("\\D", "", samplesRelated))
              nP <- max(locateParticipantID,na.rm = TRUE)
              # We locate the page ID containing the last index
              lastP <- which(grepl(nP,samplesRelated))
              # And isolate all IDs from there
              locateParameter <- samplesRelated[(lastP-nP)+1:lastP]
        }
        # We retrieve only the pages containing the parameter
        x <- postParam.Array[,,locateParameter]
return(x)
}

# A function to plot the merging chains for hierarchical parameters
plot.Chain <- function(samples){
    posterior.samples <- samples$BUGSoutput$sims.array
    labels <- names(posterior.samples[1,1,])
    locateHier <- which(grepl("_",labels))
    N <- length(locateHier)
    n.chains <- ncol(posterior.samples[,,labels[locateHier[1]]])
    par(mfrow = c(2, 3), mar =c(5.1,2,4.1,2), bty = "o")
    for(i in locateHier){
        plot(posterior.samples[,1,i], type="l", main=labels[i], 
             xlab="Iteration", ylab="Value sampled")  
        if(n.chains>1){
             for(a in 2:n.chains){
             lines(posterior.samples[,a,i],col=a)
             }
          }
    }
}

# A function to compute the difference between the true value and estimate retrieved for every parameter.
getError <- function(estimates, parameter_set){
  error <- list("bound" = estimates$bound - parameter_set$bound,
                "nondt" = estimates$nondt - parameter_set$nondt,
                "drift" = estimates$drift - parameter_set$drift,
                "bound_mean" = estimates$bound_mean - parameter_set$bound_mean,
                "bound_sdev" = estimates$bound_sdev - parameter_set$bound_sdev,
                "nondt_mean" = estimates$nondt_mean - parameter_set$nondt_mean,
                "nondt_sdev" = estimates$nondt_sdev - parameter_set$nondt_sdev,
                "drift_mean" = estimates$drift_mean - parameter_set$drift_mean,
                "drift_sdev" = estimates$drift_sdev - parameter_set$drift_sdev)
  return(error)
}

#
recoveryPlot <- function(x.true, y.estimated, parameterName){
  allValues <- c(x.true,y.estimated)
  param.is.bound <- length(which(grepl("ound",parameterName)))!=0
  param.is.nondt <- length(which(grepl("no",parameterName)))!=0
  if(param.is.bound){   color <- "blueviolet"
  }else{if(param.is.nondt){   color <- "dodgerblue4"
  }else{  color <- "goldenrod4" }}
  par(bty="o")
  plot(x.true,y.estimated, ann=F, col=color, pch=16,
       xlim=c(min(allValues),max(allValues)),
       ylim=c(min(allValues),max(allValues)))
  abline(0,1, lty=2)
  mtext("Simulated values", 1, line=2.1, cex=0.7)
  mtext(parameterName, 3, line=0.5, cex=0.8, f=2)
}

showRecovery <- function(simStudy, nParticipants, nTrials){
  par(mfrow = c(2, 3), mar =c(5.1,2,4.1,2))
  recoveryPlot(simStudy[,"true","drift_mean"],simStudy[,"est","drift_mean"],"Group mean drift")
  recoveryPlot(simStudy[,"true","bound_mean"],simStudy[,"est","bound_mean"],"Group mean bound")
  recoveryPlot(simStudy[,"true","nondt_mean"],simStudy[,"est","nondt_mean"],"Group mean nondt")
  recoveryPlot(simStudy[,"true","drift"],simStudy[,"est","drift"],"Individual drifts")
  recoveryPlot(simStudy[,"true","bound"],simStudy[,"est","bound"],"Individual bounds")
  recoveryPlot(simStudy[,"true","nondt"],simStudy[,"est","nondt"],"Individual nondt")
  title <- paste(nParticipants, " participants, ", nTrials, " trials each")
mtext(title, side = 3, line =-1.7, outer = TRUE, f=2, col="red3")
}
```

## Core functions

```{r}
# Sample data using simulation settings and true parameter values sampled
sample_data <- function(settings, parameter_set){
  nObs <- settings$nPart*settings$nTrials
  data <- matrix(NA,ncol=3,nrow=nObs)
  data[,1] <- rep(1:settings$nPart, each=settings$nTrials)
  for(i in 1:settings$nP){      # Get data for every Participant
      this.sub <- which(data[,1]==i)
      accuracy = 0
      while(sum(accuracy)==0){
            temp <- wdmrnd(a = parameter_set$bound[i], v = parameter_set$drift[i], 
                           t = parameter_set$nondt[i], n = settings$nTrials)
            accuracy = temp$accuracy
      }
      data[this.sub,3] <- accuracy
      data[this.sub,2] <- temp$RT
  }
  data <- as.data.frame(data)
  colnames(data) <- c("sub", "rt", "accuracy")
  return(data)
}

# Get individual statistics from raw data: mean accuracy and mean and variance of correct-RT
get_Statistics <- function(data){
  if(is.null(data$accuracy)|is.null(data$rt)){
        error.msg = "Data not available."
        return(print(error.msg))
    }
  subID <- unique(data$sub)
  sum_correct <- tapply(data$accuracy, data$sub, sum)  
  # Remove participants with no correct answer
  always_0 <- which(sum_correct==0)
  if(length(always_0)!=0){
        bad_participants <- (data$sub %in% always_0)
        data <- data[-bad_participants,]
        sum_correct <- tapply(data$accuracy, data$sub, sum) 
  }
  # Get proportion of correct responses
  mean_accuracy <- tapply(data$accuracy, data$sub, mean) 
  # Get mean and variance of correct RT
  keep.correct <- which(data$accuracy==1)
  correct_only <- data[keep.correct,]
  mean_rt_correct <- tapply(correct_only$rt, correct_only$sub, mean)
  var_rt_correct  <- tapply(correct_only$rt, correct_only$sub, var)
  # Create a data.frame with just summary statistics
  data_statistics <- cbind(subID, sum_correct, mean_accuracy, mean_rt_correct, var_rt_correct)
  data_statistics <- as.data.frame(data_statistics)
  colnames(data_statistics) = c("sub", "sum_correct","meanAccuracy", "meanRT_correct", "varRT_correct")
  return(data_statistics)
}
```

## Main functions

```{r}
# A function to load priors and true values to use in simulation
Hddm_Parameter_Set <-function(nParticipants, nTrials, Show=TRUE){
    if(Show){  design_summary(nParticipants,nTrials)  }
    prior <- default_priors(Show)
    settings <- list("nPart"= nParticipants, "nTrials"= nTrials, "prior"= prior)
    parameter_set <- sample_parameters(settings, Show)
    return(list("settings" = settings, "parameter_set" = parameter_set))
}

# A function to generate raw data, summary statistics and data to be passed on JAGS
Hddm_Data <- function(settings, parameter_set){
    rawData = sample_data(settings,parameter_set)
    sumData = get_Statistics(rawData)
    jagsData = data_toJAGS()
    return(list("rawData" = rawData, "sumData" = sumData, "jagsData" = jagsData))
}

# A function to run JAGS model
Hddm_runJAGS <- function(getData, settings, n.chains, modelFile="./EZHBDDM.bug", plot.Chains = FALSE){
    # Write model
    write_JAGSmodel(settings$prior)
    # Load settings
    parameters <- c("bound_mean", "drift_mean", "nondt_mean", "bound", "nondt",
                    "drift_sdev", "nondt_sdev", "bound_sdev", "drift")
    myinits    <- default_inits(n.chains, settings$nPart)
    data <- getData$jagsData
    # Prepare data
    sub     <- getData$sumData$sub
    correct <- getData$sumData$sum_correct
    varRT   <- getData$sumData$varRT_correct
    meanRT  <- getData$sumData$meanRT_correct
    nTrialsPerPerson <- as.numeric(unique(tapply(getData$rawData$accuracy,getData$rawData$sub,length)))
    nParticipants    <- length(getData$sumData$sub)
    # Run model and get samples
    suppressMessages(library(R2jags))
    suppressMessages(samples <- jags(data=data, 
                                parameters.to.save=parameters, 
                                model=modelFile, 
                                n.chains=n.chains, 
                                n.iter=1000, 
                                n.burnin=200, 
                                n.thin=1, 
                                DIC=T, 
                                inits=myinits))
    if(plot.Chains){  plot.Chain(samples)   }
return(list("drift" = apply(extractSamples("drift", samples),3,mean), 
            "drift_mean" = mean(extractSamples("drift_mean", samples)),
            "drift_sdev" = mean(extractSamples("drift_sdev", samples)),  
            "bound" = apply(extractSamples("bound", samples),3,mean), 
            "bound_mean" = mean(extractSamples("bound_mean", samples)),
            "bound_sdev" = mean(extractSamples("bound_sdev", samples)),
            "nondt" = apply(extractSamples("nondt", samples),3,mean), 
            "nondt_mean" = mean(extractSamples("nondt_mean", samples)),
            "nondt_sdev" = mean(extractSamples("nondt_sdev", samples))))
}

# Main function: A function to run a complete simulation for nParticipants and nTrials per participant
Hddm_runSim <- function(nParticipants, nTrials, n.chains = 4, Show=TRUE){
      design.parameters <- Hddm_Parameter_Set(nParticipants,nTrials, Show=Show)
      settings <- design.parameters$settings
      parameter_set <- design.parameters$parameter_set
      getData <- Hddm_Data(settings,parameter_set)
      estimates <- Hddm_runJAGS(getData=getData, n.chains = n.chains, settings = settings)
      error <- getError(estimates, parameter_set)
return(list("trueValues" = parameter_set, "estValues" = estimates, "error" = error))
}


Hddm_simStudy <- function(nSim, nParticipants, nTrials, n.chains = 4, 
                          outputFile = "./output_simStudy.RData", Show=FALSE, forceSim = FALSE){
    runSim <- TRUE
    if((!forceSim)&(file.exists(outputFile))){runSim <- FALSE}
    if(runSim){
      simOutput <- array(NA, dim=c(nSim,3,3))
      for(k in 1:nSim){
          set.seed(k)
          cat("Iteration", k, "of", nSim,"\n")
          tryCatch({
            sim <- Hddm_runSim(nParticipants = 50, nTrials = 150, Show = FALSE)
            simOutput[k,,1] <- c(sim$trueValues$drift_mean, sim$estValues$drift_mean, sim$error$drift_mean)
            simOutput[k,,2] <- c(sim$trueValues$bound_mean, sim$estValues$bound_mean, sim$error$bound_mean)
            simOutput[k,,3] <- c(sim$trueValues$nondt_mean, sim$estValues$nondt_mean, sim$error$nondt_mean)},
            error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
      }
      simOutput <- simOutput[which(!is.na(simOutput[,1,1])),,]
      dimnames(simOutput) <- list(NULL, c("true","est","error"), c("drift_mean","bound_mean","nondt_mean"))
      save(simOutput,file=outputFile)
    }else{    load(outputFile)     }
    return(simOutput)
}
```

\clearpage

# Run simple example


```{r}
sim <- Hddm_runSim(nParticipants = 50, nTrials = 150)
```

\vspace{-0.5in}

```{r, echo=FALSE, fig.height=3, fig.align='center'}
par(mfrow = c(1, 3), mar =c(5.1,2,4.1,2))
recoveryPlot(sim$trueValues$bound,sim$estValues$bound, "Individual bound")
recoveryPlot(sim$trueValues$nondt,sim$estValues$nondt, "Individual nondt")
recoveryPlot(sim$trueValues$drift,sim$estValues$drift, "Individual drift")
```

# Smulation study (150 trials - 200 repetitions)

\vspace{-0.1in}

```{r, message=FALSE, results='hide', echo=FALSE, fig.width=5.5, fig.height=2.3, fig.align='center'}
nT <- 150
nP <- 50
simStudy <- Hddm_simStudy(nSim = 200, nParticipants = nP, nTrials = nT, outputFile = "./sim_P50T150.RData")
showRecovery(simStudy, nP, nT)
```

\vspace{-0.4in}

```{r, message=FALSE, results='hide', echo=FALSE, fig.width=5.5, fig.height=2.3, fig.align='center'}
nP <- 200
simStudy <- Hddm_simStudy(nSim = 200, nParticipants = nP, nTrials = nT, outputFile = "./sim_P200T150.RData")
showRecovery(simStudy, nP, nT)
```


\vspace{-0.4in}

```{r, message=FALSE, results='hide', echo=FALSE, fig.width=5.5, fig.height=2.3, fig.align='center'}
# 500 participants, 10 trials each
simStudy <- Hddm_simStudy(nSim = 200, nParticipants = 500, nTrials = 10, outputFile = "./simStudy_p500t10.RData")

par(mfrow = c(1, 3), mar =c(5.1,2,4.1,2))
recoveryPlot(simStudy[,"true","drift_mean"],
             simStudy[,"est","drift_mean"],
             "Group mean drift")
recoveryPlot(simStudy[,"true","bound_mean"],
             simStudy[,"est","bound_mean"],
             "Group mean bound")
recoveryPlot(simStudy[,"true","nondt_mean"],
             simStudy[,"est","nondt_mean"],
             "Group mean nondt")
mtext("500 participants, 10 trials each", side = 3, line =-1.7, outer = TRUE, f=2, col="red3")
```


