---
title: "EZBHDDM - Hypothesis testing example"
author: "Adriana F. Chávez De la Peña and Joachim Vandekerckhove"
date: "`r Sys.Date()`"
output:
  rmdformats::material:
    self_contained: true
    thumbnails: false
    lightbox: true
    gallery: true
    cards: false
    highlight: tango
    fig_width: 12 
    fig_height: 8 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rmdformats)
```
# Introduction

Data from [Vandekerckhove, Panis and Wagemans (2007)](https://link.springer.com/article/10.3758/BF03193960)


```{r, message=FALSE}
# Load necessary libraries/packages
library(R2jags)
seed <- 15
```

# Loading and prepare the data

### Load the data

```{r}
data_raw <- read.csv("./vpw08.csv")
colnames(data_raw) <- c("sub", "change_quality", "change_type", "noChange", "response", "rt")
head(data_raw)

# No. of observations
nrow(data_raw)
```

### Prepare the data

```{r}
tmp <- data_raw[which(data_raw$rt<=3),]
change <- 1-tmp$noChange

cond <- rep(0,nrow(tmp))
cond[which(tmp$change_quality==0&tmp$change_type==0)] <- 1
cond[which(tmp$change_quality==1&tmp$change_type==0)] <- 2
cond[which(tmp$change_quality==0&tmp$change_type==1)] <- 3
cond[which(tmp$change_quality==1&tmp$change_type==1)] <- 4
cond[which(change==0)] <- 5

data <- data.frame("sub" = tmp$sub, "cond" = cond, "change" = change, 
                   "change_quality" = tmp$change_quality, "change_type" = tmp$change_type,
                   "response" = tmp$response, "rt" = tmp$rt)
```

# Get summary statistics

**Note:** Since the three-parameters considered by the EZDDM formulation don't predict any difference in shape between the correct and incorrect RT distributions, we use all trials to compute the mean and variance of the RT.

### Write custom function `ez_summaries`

```{r}
# Define a function to compute the summary statistics used by EZ-DDM
ez_summaries <- function(data){
  # Identify condition ID
  cond <- unique(data$cond)
  sub <- unique(data$sub)
  
  output<- c()
  for(i in sort(sub)){
      for(k in sort(cond)){
          subset <- data[which(data$sub==i&data$cond==k),]
          output <- rbind(output, c("sub" = unique(subset$sub), "cond" = unique(subset$cond),
                            "change" = unique(subset$change), 
                            "change_quality" = unique(subset$change_quality),
                            "change_type" = unique(subset$change_type),
                            "nTrials" = nrow(subset), "score" = sum(subset$response),
                            "meanRT"  = mean(subset$rt), "varRT"= var(subset$rt)))
      }
  }
  
  return(as.data.frame(output))
}
```

### Compute summary statistics from data

```{r}
ezdata <- ez_summaries(data)
ezdata$acc_rate <- ezdata$score/ezdata$nTrials
```

# The model 

### EZHBDM

The first component of the model is what we called 'the proxy' model: We use the sampling distributions for the three summary statistics computed from the data, (i.e., the number of correct responses $\dot{T}$ and the mean $\dot{M}$ and variance $\dot{V}$ of the response times), which are built from the forward-system of equations in the EZDDM that characterize the proportion of correct responses `PC`, and the mean and precision of the RTs `MRT`, `PRT`.

\begin{align*}
\dot{T} &\sim \mbox{Binomial}(PC,N)\\
\dot{V} &\sim \mbox{Normal}(\frac{1}{PRT},\frac{N-1}{2(PRT)^2})\\
\dot{M} &\sim \mbox{Normal}(MRT, PRT \times N)\\
PC &= \frac{1}{\exp(-\alpha\nu)+1}\\
MRT &= \tau + \frac{\alpha}{2\nu}\frac{\exp(-\alpha\nu)-1}{\exp(-\alpha\nu)+1}\\
PRT &= \frac{\alpha}{2\nu^3}\{\frac{1-2\alpha\nu\exp(-\alpha\nu)-\exp(-\alpha\nu)^2}{(\exp(-\alpha\nu)+1)^2}\}
\end{align*}

### Meta-regression structure

We model the variability in the drift rate $\drift$ parameter across conditions $k$ by fitting a multiple linear regression

\vspace{-0.2in}

\begin{align*}
\drift^{pred}_k &= \mu_\drift+X_k(\gamma_1Z_k+\gamma_2Y_k+\gamma_3Y_kZ_k)+\gamma_4(1-X_k)\\
\drift_k &\sim \mbox{Normal}(\drift^{pred}_k,\sigma_\drift)
\end{align*}

so that the drift rate predicted for every condition $\drift^{pred}_k$ depends on the configuration of the three dummy variables and their interaction with five different regression coefficients.

```{r}
# Is there a change?
# Yes (1) / No (0)
X <- ezdata$change

# Change quality
# Quantitative (1) / Qualitative (0)
Y <- ezdata$change_quality

# Change type
# Concavity (1) / Convexity (0)
Z <- ezdata$change_type
```


### Write the model in JAGS

```{r}
model <- write("
model {
          ####### Priors
          drift_mu ~ dnorm(0,1)   # Baseline
          drift_lambda ~ dgamma(2,1)
          drift_sigma = pow(drift_lambda, -0.5)
          for(i in 1:4){
              gamma[i] ~ dnorm(0,1)   
          }      
          
          ####### Sampling model
          for (k in 1:length(nTrials)) {
              # Person-by-condition parameters for DM parameters
              bound[k] ~ dgamma(2,1)
              nondt[k] ~ dexp(1)
              drift_pred[k] = drift_mu + X[k]*(gamma[1]*Y[k]+gamma[2]*Z[k]+gamma[3]*Y[k]*Z[k])   
                              + (1-X[k])*gamma[4]
              drift[k] ~ dnorm(drift_pred[k],drift_lambda)
      
              # Forward equations from EZ Diffusion
              ey[k]  = exp(-bound[k] * drift[k])
              Pc[k]  = 1 / (1 + ey[k])
              PRT[k] = 2 * pow(drift[k], 3) / bound[k] * pow(ey[k] + 1, 2) / (2 * -bound[k] * 
                       drift[k] * ey[k] - ey[k] * ey[k] + 1)
              MDT[k] = (bound[k] / (2 * drift[k])) * (1 - ey[k]) / (1 + ey[k])
              MRT[k] = MDT[k] + nondt[k]
      
              # Sampling distributions for summary statistics
              correct[k] ~ dbin(Pc[k], nTrials[k])
              varRT[k]   ~ dnorm(1/PRT[k], 0.5*(nTrials[k]-1) * PRT[k] * PRT[k])
              meanRT[k]  ~ dnorm(MRT[k], PRT[k] * nTrials[k])
            }
}", "./model_shapePerception.bug")
```


# JAGS


### Specify JAGS setup

```{r}
# General setup
n.chains  <- 4;      n.iter    <- 2500
n.burnin  <- 250;    n.thin    <- 1

# Pass data to JAGS
data_toJAGS <- list("nTrials"  =  ezdata$nTrials,
                    "meanRT"   =  ezdata$meanRT,
                    "varRT"    =  ezdata$varRT,
                    "correct"  =  ezdata$score,
                    "X" = X, "Y" = Y, "Z" = Z)

# Specify parameters to keep track of
parameters <- c('gamma', 'drift_mu', 'drift_lambda', 'drift_sigma', 'drift_pred',
                'drift','bound', 'nondt', "Pc", "PRT", "MRT")
```

```{r}
set.seed(seed)

# Prepare initial values
myinits <- rep(list(list()), n.chains)
for(i in 1:n.chains){
    myinits[[i]] <- list(drift = rnorm(nrow(ezdata),0,1))
}
```

### Run JAGS

```{r}
set.seed(seed)

samples <- jags(data=data_toJAGS,
                parameters.to.save=parameters,
                model="./model_shapePerception.bug",
                n.chains=n.chains,  n.iter=n.iter,
                n.burnin=n.burnin,  n.thin=n.thin,
                DIC=T, inits=myinits)
```

### Extract posterior samples

```{r}
##### Drift rate parameters
# Recovered drift rates
drift <- samples$BUGSoutput$sims.list$drift
# Regression coefficients
mu <- samples$BUGSoutput$sims.list$drift_mu
gamma <- samples$BUGSoutput$sims.list$gamma
# Fitted values / Predicted drift rates
drift_pred <- samples$BUGSoutput$sims.list$drift_pred

##### Summary statistics computed from the recovered drift and boundary
Pc   <- samples$BUGSoutput$sims.list$Pc
PRT  <- samples$BUGSoutput$sims.list$PRT
MRT  <- samples$BUGSoutput$sims.list$MRT
```

### Obtain posterior predicted summary statistics

```{r}
set.seed(seed)

# Number of trials per condition
nTrials <- ezdata$nTrials
# Number of posterior samples
n <- nrow(Pc) 
# Number of conditions
J <- ncol(Pc)
# Empty matrices to store posterior predictions
pp_accRate <- matrix(NA, nrow=n, ncol=J)
pp_meanRT  <- matrix(NA, nrow=n, ncol=J)
pp_varRT   <- matrix(NA, nrow=n, ncol=J)
# Obtain posterior predictions using sampling distributions
#        and the summary statistics derived from the recovered
#        drift and boundary parameters
for(i in 1:J){
  correct  <-  rbinom(n,nTrials[i],Pc[,i])
  pp_accRate[,i] <- correct/nTrials[i]
  pp_varRT[,i]   <- rnorm(n,1/PRT[,i], sqrt(2/((nTrials[i]-1) * PRT[,i] * PRT[,i])))
  pp_meanRT[,i]  <- rnorm(n,MRT[,i],sqrt(1/(PRT[,i]*nTrials[i])))
}
```

# Posterior distributions

## Baseline Drift rate

```{r, fig.align='center'}
line.mu  <- "#DC9F12"
curve.mu <- "#F2D79A"
hist(mu, freq = FALSE, breaks = 50, col=curve.mu, border = curve.mu, ann=F, axes = T)
lines(density(mu), lwd=4, col=line.mu)
legend("topleft",c("Histogram","KDE"),col=c(curve.mu,line.mu),lwd=4, cex=1.1, bty = "n")
mtext("Baseline drift rate: Qualitative change in convexity", cex=1.2, f=2, side=3, line=0.8)
mtext("Density",side=2,line=2.15)
mtext("drift_mu - Baseline drift rate",side=1,line=2)
box(col="black")
```


## Effect of a Qualitative change

```{r, fig.align='center'}
line.mu  <- "#DC9F12"
curve.mu <- "#F2D79A"
hist(gamma[,1], freq = FALSE, breaks = 50, col=curve.mu, border = curve.mu, ann=F, axes = T)
lines(density(gamma[,1]), lwd=4, col=line.mu)
legend("topleft",c("Histogram","KDE"),col=c(curve.mu,line.mu),lwd=4, cex=1.1, bty = "n")
mtext("Baseline drift rate: Qualitative change in convexity", cex=1.2, f=2, side=3, line=0.8)
mtext("Density",side=2,line=2.15)
mtext("drift_mu - Baseline drift rate",side=1,line=2)
box(col="black")
```

## Effect of a change on Concavity

```{r, fig.align='center'}
line.mu  <- "#DC9F12"
curve.mu <- "#F2D79A"
hist(gamma[,2], freq = FALSE, breaks = 50, col=curve.mu, border = curve.mu, ann=F, axes = T)
lines(density(gamma[,2]), lwd=4, col=line.mu)
legend("topleft",c("Histogram","KDE"),col=c(curve.mu,line.mu),lwd=4, cex=1.1, bty = "n")
mtext("Baseline drift rate: Qualitative change in convexity", cex=1.2, f=2, side=3, line=0.8)
mtext("Density",side=2,line=2.15)
mtext("drift_mu - Baseline drift rate",side=1,line=2)
box(col="black")
```


## Interaction effect

```{r, fig.align='center'}
line.mu  <- "#DC9F12"
curve.mu <- "#F2D79A"
hist(gamma[,3], freq = FALSE, breaks = 50, col=curve.mu, border = curve.mu, ann=F, axes = T)
lines(density(gamma[,3]), lwd=4, col=line.mu)
legend("topleft",c("Histogram","KDE"),col=c(curve.mu,line.mu),lwd=4, cex=1.1, bty = "n")
mtext("Baseline drift rate: Qualitative change in convexity", cex=1.2, f=2, side=3, line=0.8)
mtext("Density",side=2,line=2.15)
mtext("drift_mu - Baseline drift rate",side=1,line=2)
box(col="black")
```

## Effect of not observing any change

```{r, fig.align='center'}
line.mu  <- "#DC9F12"
curve.mu <- "#F2D79A"
hist(gamma[,4], freq = FALSE, breaks = 50, col=curve.mu, border = curve.mu, ann=F, axes = T)
lines(density(gamma[,4]), lwd=4, col=line.mu)
legend("topleft",c("Histogram","KDE"),col=c(curve.mu,line.mu),lwd=4, cex=1.1, bty = "n")
mtext("Baseline drift rate: Qualitative change in convexity", cex=1.2, f=2, side=3, line=0.8)
mtext("Density",side=2,line=2.15)
mtext("drift_mu - Baseline drift rate",side=1,line=2)
box(col="black")
```




```{r}
# Identify conditions to plot on x axis
x_values <- unique(df$Xs)
# Insert a 'jump' in between these values
fit_x <- c(x_values[1:16],NA,x_values[17:32])
full_x <- c(fit_x,NA,fit_x+6.8)
```

## Drift rates predicted and recovered

```{r}
#### Get mean posterior estimates and percentiles for plotting
# Drift recovered
means <- apply(drift, 2, mean)
percentiles <- apply(drift,2, quantile, probs=c(0.025,0.975))
lower_percentiles <- percentiles[1,]  #  2.5%
upper_percentiles <- percentiles[2,]  # 97.5%
# Drift predictions (i.e., fitted values)
preds <- apply(drift_pred,2,mean)
```

```{r, echo=FALSE, fig.align='center', out.width="100%"}
acc.bckg <- "#FCF2FF"
spd.bckg <- "#F5FAF9"

### Concatenate values by instruction and add a "jump" between pixel condition
makeLines <- function(posterior_object){
  x <- posterior_object
  line_acc <- c(x[1:16], NA,x[17:32])
  line_spd <- c(x[33:48],NA,x[49:64])
  full_line <- c(line_acc, NA, line_spd)
return(full_line)
}

means <- makeLines(means)
fit_line <- makeLines(preds)

# Lower and upper boundaries of the error bars
errors_acc <- cbind(c(lower_percentiles[1:16], NA, lower_percentiles[17:32]),
                    c(upper_percentiles[1:16], NA, upper_percentiles[17:32]))
errors_spd <- cbind(c(lower_percentiles[33:48],NA, lower_percentiles[49:64]),
                    c(upper_percentiles[33:48],NA, upper_percentiles[49:64]))
errors <- rbind(errors_acc,c(NA,NA),errors_spd)

par(pty="m", mfrow = c(1,1), mai=c(1.1,0.6,0.5,0), oma= c(0,0,0,0))
predicted.color  <- "#FF8B0F"
recovered.color <- "#83460A"
point.size <- 1

plot(full_x,fit_line, type="l", lwd=4, col=predicted.color, ann=F, axes=F,
     ylab="Drift rate", ylim=c(0,6),xaxs = "i", yaxs = "i", xlim=c(-3.5,10.3))
# Gray background
polygon(c(-3.5,3.5,3.5,-3.5),c(0,0,6,6),col = acc.bckg, border = "gray98", lwd = 3, lty = "solid")
polygon(c(3.5,10.3,10.3,3.5),c(0,0,6,6),col = spd.bckg, border = "gray98", lwd = 3, lty = "solid")
polygon(c(-0.04,0.04,0.04,-0.04),c(0,0,6,6),col = "gray85", border = "gray85", lwd = 3, lty = "solid")
polygon(c(6.76,6.84,6.84,6.76),c(0,0,6,6),col = "gray85", border = "gray85", lwd = 3, lty = "solid")
lines(full_x,fit_line,lwd=4,col=predicted.color)
arrows(full_x,errors[,1], full_x, errors[,2], length=0.05, angle=90, code=3, col=recovered.color)
points(full_x, means, col=recovered.color, pch=16, cex=point.size)
axis(1,c(-2,0,2,5,7,9),rep(c("More black","50/50","More white"),2), line = 0)
axis(1,c(-4,10.3),c("",""), line = 0, col.ticks = "white")
axis(2,0:6,0:6, las=2)
mtext("Drift rate", 2, line=2)
text(-2,0.35,"Accuracy", cex=1.5)
mtext("Stimulus configuration", 1, line=3)
text(9,0.35,"Speed", cex=1.5)
mtext("Predicted and recovered drift rate per condition",3,outer=TRUE, f=2, line=-1.5, cex=1.8)
```


## Posterior predictive checks

```{r}
## Get mean posteriors and key percentiles
# Accuracy rate
pp.accRate <- apply(pp_accRate, 2, mean)
pp.perc.accRate <- apply(pp_accRate,2, quantile, probs=c(0.025,0.975))
# Mean RT-correct
pp.rtMean <- apply(pp_meanRT, 2, mean)
pp.perc.rtMean <- apply(pp_meanRT,2, quantile, probs=c(0.025,0.975))
# RT-correct Variance
pp.rtVar <- apply(pp_varRT, 2, mean)
pp.perc.rtVar <- apply(pp_varRT,2, quantile, probs=c(0.025,0.975))
```

```{r, echo=FALSE}
## Concatenate per instruction condition, with a "jump" between pixel condition
est.accRate.Full   <- makeLines(pp.accRate)
est.rtMean.Full <- makeLines(pp.rtMean)
est.rtVar.Full  <- makeLines(pp.rtVar)

accRate <- makeLines(df$acc_rate)
meanRT  <- makeLines(df$mean_rt)
varRT   <- makeLines(df$variance_rt)

## Arrange lower and upper percentiles such that we can use polygon() to draw them
# Accuracy rate
err.accRate.acc  <- c(pp.perc.accRate[1,1:16],  pp.perc.accRate[2,16:1],
                      pp.perc.accRate[1,17:32], pp.perc.accRate[2,32:17])
err.accRate.spd  <- c(pp.perc.accRate[1,33:48], pp.perc.accRate[2,48:33],
                      pp.perc.accRate[1,49:64], pp.perc.accRate[2,64:49])
# Mean RT-correct
err.rtMean.acc  <- c(pp.perc.rtMean[1,1:16],  pp.perc.rtMean[2,16:1],
                        pp.perc.rtMean[1,17:32], pp.perc.rtMean[2,32:17])
err.rtMean.spd  <- c(pp.perc.rtMean[1,33:48], pp.perc.rtMean[2,48:33], 
                        pp.perc.rtMean[1,49:64], pp.perc.rtMean[2,64:49])
# RT-correct Variance
err.rtVar.acc  <- c(pp.perc.rtVar[1,1:16],  pp.perc.rtVar[2,16:1],
                       pp.perc.rtVar[1,17:32], pp.perc.rtVar[2,32:17])
err.rtVar.spd  <- c(pp.perc.rtVar[1,33:48], pp.perc.rtVar[2,48:33],
                       pp.perc.rtVar[1,49:64], pp.perc.rtVar[2,64:49])
```

```{r, fig.align='center', out.width="100%", echo=FALSE}
par(pty="m", mfrow = c(1,1), mai=c(1.1,0.6,0.5,0), oma= c(0,0,0,0))
data.color  <- "black"
point.size <- 0.9
error.color <- "#E69FF8"
pred.color <- "#BE07C1"

predAccuracy_plot <- function(accRate, est.accRate.Full, err.accRate.acc, err.accRate.spd){
    plot(full_x,est.accRate.Full, col="white", ann=F, axes=F, 
         ylim=c(0.45,1.05),xaxs = "i", yaxs = "i", xlim=c(-3.5,10.3))
    polygon(c(-3.5,3.5,3.5,-3.5),c(0,0,6,6),col = acc.bckg, border = "gray98", lwd = 3, lty = "solid")
    polygon(c(3.5,10.3,10.3,3.5),c(0,0,6,6),col = spd.bckg, border = "gray98", lwd = 3, lty = "solid")
    polygon(c(-0.04,0.04,0.04,-0.04),c(0,0,6,6),col = "gray85", border = "gray85", lwd = 3, lty = "solid")
    polygon(c(6.76,6.84,6.84,6.76),c(0,0,6,6),col = "gray85", border = "gray85", lwd = 3, lty = "solid")
    polygon(c(full_x[1:16],full_x[16:1]),err.accRate.acc[1:32],col = error.color, border = NA, lwd = 3, lty = "solid")
    polygon(c(full_x[18:33],full_x[33:18]),err.accRate.acc[33:64],col = error.color, border = NA, lwd = 3, lty = "solid")
    polygon(c(full_x[35:50],full_x[50:35]),err.accRate.spd[1:32],col = error.color, border = NA, lwd = 3, lty = "solid")
    polygon(c(full_x[52:67],full_x[67:52]),err.accRate.spd[33:64],col = error.color, border = NA, lwd = 3, lty = "solid")
    lines(full_x,est.accRate.Full,col=pred.color, lwd=3)
    points(full_x,accRate,pch=8,col=data.color, cex=0.7)
    axis(1,c(-2,0,2,5,7,9),rep(c("More black","50/50","More white"),2), line = 0)
    axis(1,c(-4,10.3),c("",""), line = 0, col.ticks = "white")
    axis(2,seq(0,1,0.1),seq(0,1,0.1), las=2)
    text(2.5, 0.47, "Accuracy")
    text(4.2, 0.47, "Speed")
    mtext("Stimulus configuration", 1, line=3)
    abline(h=0.5,lty=2, col="gray50")
    text(9,0.52,"50% accuracy",col="gray50", cex=0.7)
    mtext("Accuracy rate per condition",3,outer=TRUE, f=2, line=-1.5, cex=1.8)
}

predAccuracy_plot(accRate, est.accRate.Full, err.accRate.acc, err.accRate.spd)
```

```{r, fig.align='center', out.width="100%", echo=FALSE}
par(pty="m", mfrow = c(1,1), mai=c(1.1,0.6,0.5,0), oma= c(0,0,0,0))
error.color <- "#6DFA9C"
pred.color <- "#00A437"
point.size <- 0.9


predMeanRT_plot <- function(est.rtMean.Full, meanRT, err.rtMean.acc, err.rtMean.spd){
    plot(full_x,est.rtMean.Full, col="white", ann=F, axes=F, ylim=c(0.2,1), 
         xaxs = "i", yaxs = "i", xlim=c(-3.5,10.3))
    polygon(c(-3.5,3.5,3.5,-3.5),c(0,0,6,6),col = acc.bckg, border = "gray98", lwd = 3, lty = "solid")
    polygon(c(3.5,10.3,10.3,3.5),c(0,0,6,6),col = spd.bckg, border = "gray98", lwd = 3, lty = "solid")
    polygon(c(-0.04,0.04,0.04,-0.04),c(0,0,6,6),col = "gray85", border = "gray85", lwd = 3, lty = "solid")
    polygon(c(6.76,6.84,6.84,6.76),c(0,0,6,6),col = "gray85", border = "gray85", lwd = 3, lty = "solid")
    polygon(c(full_x[1:16],full_x[16:1]),err.rtMean.acc[1:32],col = error.color,
            border = NA, lwd = 3, lty = "solid")
    polygon(c(full_x[18:33],full_x[33:18]),err.rtMean.acc[33:64],col = error.color,
            border = NA, lwd = 3, lty = "solid")
    polygon(c(full_x[35:50],full_x[50:35]),err.rtMean.spd[1:32],col = error.color,
            border = NA, lwd = 3, lty = "solid")
    polygon(c(full_x[52:67],full_x[67:52]),err.rtMean.spd[33:64],col = error.color,
            border = NA, lwd = 3, lty = "solid")
    lines(full_x,est.rtMean.Full,col=pred.color, lwd=3)
    points(full_x,meanRT,pch=8,col=data.color, cex=0.7)
    axis(1,c(-2,0,2,5,7,9),rep(c("More black","50/50","More white"),2), line = 0)
    axis(1,c(-4,10.3),c("",""), line = 0, col.ticks = "white")
    axis(2,seq(0,1,0.1),seq(0,1,0.1), las=2)
    mtext("Mean RT (secs)", 2, line=2.2)
    mtext("Stimulus configuration", 1, line=3)
    text(2.5, 0.95, "Accuracy")
    text(4.2, 0.95, "Speed")
    mtext("Mean RT per condition",3,outer=TRUE, f=2, line=-1.5, cex=1.8)
}


predMeanRT_plot(est.rtMean.Full, meanRT, err.rtMean.acc, err.rtMean.spd)
```

```{r, fig.align='center', out.width="100%", echo=FALSE}
par(pty="m", mfrow = c(1,1), mai=c(1.1,0.6,0.5,0), oma= c(0,0,0,0))
error.color <- "#8CE0FF"
pred.color <- "#095B79"

predVarRT_plot <- function(varRT, est.rtVar.Full, err.rtVar.acc, err.rtVar.spd){
    plot(full_x,est.rtVar.Full, col="white", ann=F, axes=F, ylim=c(0,0.4),
         xaxs = "i", yaxs = "i", xlim=c(-3.5,10.3))
    polygon(c(-3.5,3.5,3.5,-3.5),c(0,0,6,6),col = acc.bckg, border = "gray98", lwd = 3, lty = "solid")
    polygon(c(3.5,10.3,10.3,3.5),c(0,0,6,6),col = spd.bckg, border = "gray98", lwd = 3, lty = "solid")
    polygon(c(-0.04,0.04,0.04,-0.04),c(0,0,6,6),col = "gray85", border = "gray85", lwd = 3, lty = "solid")
    polygon(c(6.76,6.84,6.84,6.76),c(0,0,6,6),col = "gray85", border = "gray85", lwd = 3, lty = "solid")
    polygon(c(full_x[1:16],full_x[16:1]),err.rtVar.acc[1:32],col = error.color,
            border = NA, lwd = 3, lty = "solid")
    polygon(c(full_x[18:33],full_x[33:18]),err.rtVar.acc[33:64],col = error.color,
            border = NA, lwd = 3, lty = "solid")
    polygon(c(full_x[35:50],full_x[50:35]),err.rtVar.spd[1:32],col = error.color,
            border = NA, lwd = 3, lty = "solid")
    polygon(c(full_x[52:67],full_x[67:52]),err.rtVar.spd[33:64],col = error.color,
            border = NA, lwd = 3, lty = "solid")
    lines(full_x,est.rtVar.Full,col=pred.color, lwd=3)
    points(full_x,varRT,pch=8,col=data.color, cex=0.7)
    axis(1,c(-2,0,2,5,7,9),rep(c("More black","50/50","More white"),2), line = 0)
    axis(1,c(-4,10.3),c("",""), line = 0, col.ticks = "white")
    axis(2,seq(0,1,0.1),seq(0,1,0.1), las=2)
    mtext("RT variance", 2, line=2.2)
    text(2.5, 0.37, "Accuracy")
    text(4.2, 0.37, "Speed")
    mtext("Stimulus configuration", 1, line=3)
    mtext("RT Variance per condition",3,outer=TRUE, f=2, line=-1.5, cex=1.8)
}

predVarRT_plot(varRT, est.rtVar.Full, err.rtVar.acc, err.rtVar.spd)
```

